package com.neptunedreams.framework;

import com.neptunedreams.framework.exception.ResponseException;
import com.neptunedreams.heroes.model.Id;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;

/**
 * <p>Created by IntelliJ IDEA.
 * <p>Date: 10/7/18
 * <p>Time: 9:38 AM
 *
 * @author Miguel Mu\u00f1oz
 */

@SuppressWarnings("HardCodedStringLiteral")
public enum ResponseUtility {
	;
	private static final Logger log = LoggerFactory.getLogger(ResponseUtility.class);

	public static InternalServerErrorException logAndMakeGenericErrorResponse(RuntimeException t) {
		log.error(t.getMessage(), t);
		return new InternalServerErrorException(t);
	}


	public static Id buildId(Integer id) {
		Id response = new Id();
		response.setId(id);
		return response;
	}

	/**
	 * Serve the data, using HttpStatus.CREATED as the response if successful. This method delegates the work to serve().
	 *
	 * @param method The service method that does the work of the service, and returns an instance of type T
	 * @param <T>    The return type
	 * @return A {@literal ResponseEntity<T>} holding the value returned by the ServiceMethod's doService() method.
	 * @see #serve(HttpStatus, ServiceMethod)
	 * @see ServiceMethod#doService()
	 * @throws ResponseException If something goes wrong. Various subclasses of ResponseException specify an HttpStatus 
	 * value
	 */
	public static <T> ResponseEntity<T> serveCreated(ServiceMethod<T> method) throws ResponseException {
		assert method != null;
		return serve(HttpStatus.CREATED, method);
	}

	/**
	 * Serve the data, using HttpStatus.OK as the response if successful. This method delegates the work to serve().
	 *
	 * @param method The service method that does the work of the service, and returns an instance of type T
	 * @param <T>    The return type
	 * @return A {@literal ResponseEntity<T>} holding the value returned by the ServiceMethod's doService() method.
	 * @see #serve(HttpStatus, ServiceMethod)
	 * @see ServiceMethod#doService()
	 * @throws ResponseException If something goes wrong. Various subclasses of ResponseException specify an HttpStatus 
	 * value
	 */
	public static <T> ResponseEntity<T> serveOK(ServiceMethod<T> method) throws ResponseException {
		return serve(HttpStatus.OK, method);
	}

	/**
	 * Serve the data, using HttpStatus.OK as the response if successful. This method delegates the work to serveVoid().
	 * Returns an empty Response, of type Void.
	 * @param method The {@code void} service method that does the work of the service
	 * @return A {@literal ResponseEntity<Void>}
	 * @throws ResponseException If something goes wrong. Various subclasses of ResponseException specify an HttpStatus 
	 * value
	 */
	public static ResponseEntity<Void> serveVoidOK(ServiceVoidMethod method) throws ResponseException {
		return serveVoid(HttpStatus.OK, method); 
	}

	/**
	 * Execute a service that returns no data. 
	 * @param successStatus The status to use if the ServiceMethod's doService() method (the lambda expression) completes
	 *                      successfully.
	 * @param method        The service method that does the work of the service.
	 * @return A {@literal ResponseEntity<Void>} with an HttpStatus indicating the result generated by the 
	 * ServiceMethod's doService() method.
	 * @throws ResponseException If something goes wrong. Various subclasses of ResponseException specify an HttpStatus 
	 * value
	 */
	public static ResponseEntity<Void> serveVoid(HttpStatus successStatus, ServiceVoidMethod method) throws ResponseException {
		return serve(successStatus, () -> {
			method.doService();
			return null; // ResponseEntity is of type Void, so returning null is fine here.
		});
	}

	/**
	 * Serve the data, specifying the HttpStatus to be used if successful, and a ServiceMethod to execute, which
	 * will usually be written as a lambda expression by the calling method. This will call the ServiceMethod's
	 * doService() method inside a try/catch block. If doService() completes successfully, this method will return
	 * the result packed inside a ResponseEntity object, using the specified successStatus. If doService throws an
	 * Exception, this method will return a ResponseEntity with the proper error HttpStatus and error message.
	 * <p>
	 * Since the doService() method is declared to return a ResponseException, the provided lambda expression need only
	 * throw a ResponseException on failure. The error handling portion of this method will use the HttpStatus specified
	 * in the ResponseException to generate the ResponseEntity.
	 * <p>
	 * This allows the developer to implement functional part of the service method inside a lambda expression without
	 * bothering with the boilerplate code used to package the successful response or handle any error.
	 * <p>
	 * <strong>Example:</strong><br>
	 * <pre>
	 *  {@literal @Override}
	 *  {@literal @RequestMapping}(value = "/menuItem/{id}", produces = {"application/json"}, method = RequestMethod.GET)
	 *   public ResponseEntity{@literal <MenuItemDto>} getMenuItem(@PathVariable("id") final Integer id) {
	 *     return serve(HttpStatus.OK, (){@literal ->} {
	 *       MenuItem menuItem = menuItemRepository.findOne(id);
	 *       confirmFound(menuItem, id); // throws ResponseException if null
	 *       MenuItemDto dto = objectMapper.convertValue(menuItem, MenuItemDto.class);
	 *       return dto;
	 *     });
	 *   }
	 * </pre>
	 *
	 * @param successStatus The status to use if the ServiceMethod's doService() method (the lambda expression) completes
	 *                      successfully.
	 * @param method        The service method that does the work of the service, and returns an instance of type T
	 * @param <T>           The return type.
	 * @return A {@literal ResponseEntity<T>} holding the value returned by the ServiceMethod's doService() method.
	 * @see ServiceMethod#doService()
	 * @see ResponseException
	 * @throws ResponseException If something goes wrong. Various subclasses of ResponseException specify an HttpStatus 
	 * value
	 */
	@SuppressWarnings("OverlyBroadThrowsClause")
	public static <T> ResponseEntity<T> serve(HttpStatus successStatus, ServiceMethod<T> method) throws ResponseException {
		assert method != null;
		try {
			// All of the work of the service goes into the method.doService() implementation.
			return new ResponseEntity<>(method.doService(), successStatus);
		} catch (ResponseException e) {
			log.debug(e.getLocalizedMessage(), e);
			throw e;
		} catch (RuntimeException re) {
//      //noinspection unchecked
//      return (ResponseEntity<T>) 
			throw logAndMakeGenericErrorResponse(re); // Sets HttpStatus to INTERNAL_SERVER_ERROR
		} catch (Error e) {

			// Errors are logged as errors, since the're caused by serious issues like bugs or resource depletion.
			log.error(e.getMessage(), e);
			//noinspection ProhibitedExceptionThrown
			throw e;
		}
	}
}

